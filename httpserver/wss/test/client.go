package main

import (
	"encoding/json"
	"fmt"
	protoutil "github.com/gogo/protobuf/proto"
	"github.com/gorilla/websocket"
	"log"
	"os"
	"os/signal"
	"xj_web_server/httpserver/wss/proto"
	"xj_web_server/util"
	"time"
)

//wss://mainnet.eos.dfuse.io/v1/stream?token=eyJ..YOURTOKENHERE...
//var addr = flag.String("addr", "ws.eospark.com", "http service address")
//var url = "ws://47.75.218.79:8206/v1/ws?apikey=ac45a8b9a11e4ec1d7a994b76f7c6f17"
//var url = "wss://ws.eospark.com/test/v1/ws?apikey=ac45a8b9a11e4ec1d7a994b76f7c6f17"
//var url = "ws://47.75.218.79:8206/v1/special?apikey=45997b4ce553445c421d98574f2cdf5a"
var url = "ws://127.0.0.1:13000/v1/wss"

//var url = "ws://47.56.172.167:13000/v1/wss?token="
//var url = "ws://127.0.0.1:13000/v1/wss?token="

//var url = "wss://ws.eospark.com/v1/ws?apikey=f216691a51597bcaa89a012cad6206e6"
//var url = "wss://mainnet.eos.dfuse.io/v1/stream?token=eyJhbGciOiJLTVNFUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJiZXRhLXVzZXJzIiwiZXhwIjoxNTQyNTk3MjA2LCJqdGkiOiJlY2RlMzRmZC0yMDM3LTRlOGYtOWY1Yi1mNGRlYmI5ZDc2ZDIiLCJpYXQiOjE1NDAwMDUyMDYsImlzcyI6ImRmdXNlLmlvIiwic3ViIjoieWhfYW5kcm9pZEAxNjMuY29tIiwic2NvcGVzIjoiKiIsIm9yaWdpbiI6IioifQ.10I8ofXuZi09jP1cEbcjwj_XAk5BlYYZjwLg-9JaWFq5YuuzGucI_SGMplRuRXkmjJzD4qY84y3Y2Dz5zvd7VA"
func main() {
	createClient()
	return
	for i := 0; i < 8000; i++ {
		go createClient()
		fmt.Println(i)
		time.Sleep(10 * time.Second)
	}
	time.Sleep(100 * time.Hour)

}

type AutoGenerated struct {
	Errno   int    `json:"errno"`
	MsgType string `json:"msg_type"`
	Errmsg  string `json:"errmsg"`
	Data    struct {
		TrxID        string `json:"trx_id"`
		BlockNum     int    `json:"block_num"`
		TrxTimestamp string `json:"trx_timestamp"`
		ActionData   struct {
			Account       string `json:"account"`
			Authorization []struct {
				Actor      string `json:"actor"`
				Permission string `json:"permission"`
			} `json:"authorization"`
			Data struct {
				From     string `json:"from"`
				Memo     string `json:"memo"`
				Quantity string `json:"quantity"`
				To       string `json:"to"`
			} `json:"data"`
			HexData string `json:"hex_data"`
			Name    string `json:"name"`
		} `json:"action_data"`
	} `json:"data"`
}

func createClient() {
	interrupt := make(chan os.Signal, 1)
	signal.Notify(interrupt, os.Interrupt)

	c, _, err := websocket.DefaultDialer.Dial(url, map[string][]string{
		"token": {"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NzQzMDcyOTEsImlzcyI6IjEwMCIsIm5iZiI6MTU3MTcxNTI5MX0.lIpO9H9fBZaawuAYjKJgt8ImdALAchwmBCI3e2sxyQVlIauuXddMEhovmJqlxZEJ7djsvZGNEyUYitY8j6HXM47gDhnamSc2Sn9C6f4LhMwlP-V1MBeiDisKho61_Fbui0fR-hqKQNbaOrvI2aLaVA695oKG7hJ7EuWJMHYVM0SOCwPBqFvFU8A086kCgzXcvSSmKRvctaJrbMfyGgLswHkBaaMnMP0XTpyoUo_0UO1PxpZqFlryapXIGd4MYsdYpFqH-K_NBXUJxznXGGVwDh8AWz73UnlCIfCzhyC4sOfW_QWx0xOhHf-krdKXhJauop22EtnXud0HFiZJHVCO5g"},
		"uid":   {"100"},
	})

	if err != nil {
		log.Fatal("dial:", err)
	} else {
		log.Printf("connecting to %s successful,waiting for heartbeat packet\n", url)
	}
	defer c.Close()

	done := make(chan struct{})
	go func() {
		defer close(done)
		for {
			_, message, err := c.ReadMessage()
			if err != nil {
				log.Println("read:", err)
				return
			}
			//校验
			if !util.IsCheckCmd(message, 100) {
				log.Println("客户端非法包", message)
				continue
			}
			var msg proto.Msg
			err = protoutil.Unmarshal(message[8:len(message)-2], &msg)
			//log.Print("recv:\n", message)

			bytes, _ := json.Marshal(msg)
			log.Print("recvMsg:\n", msg)
			log.Print("recvMessage:\n", string(message[8:len(message)-2]))
			log.Print("recvString:\n", string(msg.Data), string(bytes))
			//log.Print("recv:\n", err)
		}
	}()

	ticker := time.NewTicker(time.Second * 1)
	defer ticker.Stop()
	var i = 0
	for {
		select {
		case <-done:
			return
		case <-ticker.C:
			i++
			if i == 2 {
				// 发送订阅信息
				data := []byte("哈哈")
				//心跳
				msg := &proto.Msg{
					ErrorNo:  util.SuccessCode,
					ErrorMsg: "测试",
					Data:     data,
				}
				dataMsg, _ := protoutil.Marshal(msg)
				err := c.WriteMessage(websocket.BinaryMessage, util.CreateCmd(0x01, dataMsg, 100))
				log.Println("写数据:", util.CreateCmd(0x01, dataMsg, 100), err)
				if err != nil {
					log.Println("write:", err)
					return
				}
			}

		case <-interrupt:
			log.Println("interrupt")

			// Cleanly close the connection by sending a close message and then
			// waiting (with timeout) for the server to close the connection.
			err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, "bay bay"))
			if err != nil {
				log.Println("write close:", err)
				return
			}
			select {
			case <-done:
			case <-time.After(time.Second):
			}
			return
		}
	}
}
